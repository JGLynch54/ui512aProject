Microsoft (R) Macro Assembler (x64) Version 14.44.35214.0   08/16/25 23:41:38
ui512a.asm						     Page 1 - 1


				IFNDEF		legalnotes
 = 00000001			legalnotes	EQU		1
				.LIST
				;
				;			ui512a
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			File:			ui512a.asm
				;			Author:			John G. Lynch
				;			Legal:			Copyright @2024, per MIT License below
				;			Date:			May 13, 2024
				;
				;			Notes:
				;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
				;
				;				ui512a provides basic operations: zero, copy, compare, add, subtract.
				;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
				;               ui512md provides multiply and divide.
				;
				;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
				;				(currently using VS Community 2022 17.14.10)
				;
				;				It provides external signatures that allow linkage to C and C++ programs,
				;				where a shell/wrapper could encapsulate the methods as part of an object.
				;
				;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
				;				(Z (512), Y (256), X (128) registers, or regular Q (64bit)).
				;
				;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
				;
				;				If processor extensions are used, the caller must align the variables declared and passed
				;				on the appropriate byte boundary (e.g. alignas 64 for 512)
				;
				;				This module is very light-weight (less than 1K bytes) and relatively fast,
				;				but is not intended for all processor types or all environments. 
				;
				;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects.
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			MIT License
				;
				;			Copyright (c) 2024 John G. Lynch
				;
				;				Permission is hereby granted, free of charge, to any person obtaining a copy
				;				of this software and associated documentation files (the "Software"), to deal
				;				in the Software without restriction, including without limitation the rights
				;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				;				copies of the Software, and to permit persons to whom the Software is
				;				furnished to do so, subject to the following conditions:
				;
				;				The above copyright notice and this permission notice shall be included in all
				;				copies or substantial portions of the Software.
				;
				;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
				;				SOFTWARE.
				;
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				ENDIF			; legal notes

								INCLUDE			compile_time_options.inc
			      C IFNDEF		legalnotes
			      C ENDIF			; legalnotes
			      C 
			      C IFNDEF							compile_time_options_INC
 = 1			      C compile_time_options_INC		EQU			<1>
			      C 
			      C ;			Configuration choices
 = 00000001		      C __UseZ			EQU				1									; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY			EQU				0									; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX			EQU				0									; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000000		      C __UseQ			EQU				0									; Do not use extensions, use standard x64 bit registers and instructions
			      C ;
 = 00000001		      C __UseBMI2		EQU				1									; Bit manipulation instructions (Haswell and later) ref:https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
			      C ;
 = 00000001		      C __VerifyRegs	EQU				1									; in debug mode, or with unit tests, define routine to verify non-volatile regs 
 = 00000000		      C __CheckAlign	EQU				0									; User is expected to pass arguments aligned on 64 byte boundaries, 
			      C ;																	; This setting enforces that with a check. It should not be necessary, but included to help debugging
			      C 
			      C ENDIF			; compile_time_options_INC
			      C 
								INCLUDE			ui512aMacros.inc
			      C IFNDEF		legalnotes
			      C ENDIF			; legalnotes
			      C 
			      C IFNDEF			ui512aMacros_INC
 = 1			      C ui512aMacros_INC EQU			<1>
			      C 
			      C 
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512a.asm)
			      C 
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF		zero_u:PROC
			      C 
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF		copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF		set_uT64:PROC
			      C 
			      C ;	// s16 compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_u:PROC
			      C 
			      C ;	// s16 compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_uT64:PROC
			      C 
			      C ;	// s16 add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u:PROC
			      C 
			      C ;	// s16 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_uT64:PROC
			      C 
			      C ;	// s16 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u:PROC
			      C 
			      C ;	// s16 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_uT64:PROC
			      C ;
			      C 
			      C ;           Some coding shortcuts
 = ZMMWORD PTR		      C ZM_PTR			EQU				ZMMWORD PTR 
 = YMMWORD PTR		      C YM_PTR			EQU				YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR			EQU				XMMWORD PTR
 = QWORD PTR		      C Q_PTR			EQU				QWORD PTR
 = DWORD PTR		      C D_PTR			EQU				DWORD PTR
 = WORD PTR		      C W_PTR			EQU				WORD PTR
 = BYTE PTR		      C B_PTR			EQU				BYTE PTR
 = DWORD BCST		      C m32BCST			EQU				DWORD BCST
 = QWORD BCST		      C m64BCST			EQU				QWORD BCST
			      C LPVOID			TYPEDEF			PTR VOID
			      C ;			mask codes (for compares using instructions like VPCMPUQ)
 = 00000000		      C CPEQ			EQU				0
 = 00000001		      C CPLT			EQU				1
 = 00000002		      C CPLE			EQU				2
 = 00000003		      C CPFALSE			EQU				3
 = 00000004		      C CPNE			EQU				4
 = 00000005		      C CPGE			EQU				5
 = 00000006		      C CPGT			EQU				6
 = 00000007		      C CPTRUE			EQU				7
			      C 
			      C ;
			      C ; MemConstants <none>
			      C ;
			      C ;		Define useful constants
			      C ;		Note: this must be first in a data segment aligned (64)
			      C ;
			      C MemConstants	MACRO
			      C ; 
			      C qOnes			QWORD           8 DUP (0ffffffffffffffffh)
			      C ;
			      C zeroQ			DQ				0
			      C ; maskHex100		DD				0100h
			      C ;		Return codes commonly used.	
			      C retcode_zero	EQU				0
			      C retcode_one		EQU				1
			      C retcode_neg_one	EQU				-1
			      C ;		Sometimes need to get it from memory, not an immediate value. So:
			      C ret_zero		DD				retcode_zero						
			      C ret_one			DD				retcode_one
			      C ret_neg_one		DD				retcode_neg_one
			      C 
			      C ;		Masks commonly used
			      C ;		Record form, whic can be used as immediate values
			      C kMask			RECORD			b8:1, b7:1, b6:1, b5:1, b4:1, b3:1, b2:1, b1:1, b0:1
			      C ;		And as memory, for when immediately simply wont do
			      C mskB0			DB				1
			      C mskB1			DB				2
			      C mskB2			DB				4
			      C mskB3			DB				8
			      C mskB4			DB				16
			      C mskB5			DB				32
			      C mskB6			DB				64
			      C mskB7			DB				128
			      C mskAll8			DB				255
			      C 				ENDM
			      C 
			      C ;==================================================================================================
			      C ;           Notes on x64 calling conventions        specifically "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The callers first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address
			      C ; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile,
			      C ;	and do not need to be saved
			      C ;  ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C ;==================================================================================================
			      C 
			      C ;==================================================================================================
			      C ; Selected macros from "macamd64.inc" (c) Microsoft Corporation
			      C ;	These macros generate .xdata and .pdata entries in the executable image file.
			      C ;	The entries assist in exception and debugging; helping 'unwind' operations.
			      C ;	Only a few macros are included, and are reformatted to match coding style:
			      C ;	indents and capitalization.
			      C ;
			      C ; LEAF_ENTRY <Name>, <Section>, <NoPad>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the beginning of a leaf function.
			      C ;
			      C ;   A leaf function is one that DOES NOT:
			      C ;
			      C ;   - manipulate non-volatile registers
			      C ;   - manipulate the stack pointer
			      C ;   - call other functions
			      C ;   - reference an exception handler
			      C ;   - contain a prologue
			      C ;   - have any unwind data associated with it
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear
			      C ;
			      C ;   NoPad - If present, indicates that the function should not be prefixed
			      C ;           with 6 bytes of padding.  This is for internal use only - the
			      C ;           calling standard dictates that functions (nested and leaf) must
			      C ;           be prefixed with padding.
			      C ;
			      C Leaf_Entry		MACRO			Name, Section
			      C Section			SEGMENT			PARA 'CODE'
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			Name
			      C Name			PROC			FRAME
			      C 				.ENDPROLOG
			      C 				ENDM
			      C 
			      C ;
			      C ; LEAF_END <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the end of a leaf function.  It must be paired
			      C ;   with a LEAF_ENTRY macro that includes matching Name and Section
			      C ;   parameters.
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function.  Must match that supplied to
			      C ;          the corresponding LEAF_ENTRY macro.
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear.  Must match that supplied to the corresponding
			      C ;             LEAF_ENTRY macro.
			      C ;
			      C Leaf_End		MACRO			Name, Section
			      C Name			ENDP
			      C Section			ENDS
			      C 				ENDM
			      C 
			      C ;===========================================================================================
			      C ;          Local macros
			      C ;===========================================================================================
			      C 
			      C ;
			      C ; CheckAlign <RAddr>
			      C ;
			      C ;			Test passed variable addresses for 64 byte alignment
			      C ;			Note: Better performance if this is off, but for debugging, maybe have it on
			      C ;
			      C 
			      C CheckAlign		MACRO			Raddr
			      C 				LOCAL			ok
			      C 	IF	__CheckAlign
			      C 				TEST			Raddr, 63							; Is specified param aligned 64?
			      C 				JZ				ok									; Yes, passes test, continue
			      C 				INT				13									; No? fails, break (can substitute other exception handling)
			      C ok:
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ; VerifyRegs <none>
			      C ;
			      C ;			If option is on, generate a function, callable by unit test routines, 
			      C ;				to save non-volatile registers in passed structure.
			      C ;
			      C IF	__VerifyRegs
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* regstruct)
			      C ;			reg_verify		-	copy non-volatile regs into callers struct of nine qwords) intended for unit tests to verify non-volatile regs are not changed
			      C ;			Prototype:		-	void reg_verify( uu64* regstruct);
			      C ;			regstruct		-	Address of 9 QWORDS in a struct where regs will be copied (in RCX)
			      C ; //			reg_verify		-	save non-volatile regs for verification (debug)
			      C ; //			Prototype		-	void reg_verify ( u64* reg struct)
			      C EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* reg struct)
			      C 
			      C VerifyRegs		MACRO
			      C 				Leaf_Entry		reg_verify, ui512
			      C 				MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
			      C 				MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
			      C 				MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
			      C 				MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
			      C 				MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
			      C 				MOV				Q_PTR [ RCX ] [ 5 * 8 ], RSI
			      C 				MOV				Q_PTR [ RCX ] [ 6 * 8 ], RBX
			      C 				MOV				Q_PTR [ RCX ] [ 7 * 8 ], RBP
			      C 				MOV				Q_PTR [ RCX ] [ 8 * 8 ], RSP
			      C 				RET
			      C 				Leaf_End		reg_verify, ui512
			      C 				ENDM
			      C ENDIF
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C Zero512			MACRO			dest:REQ
			      C 	IF		__UseZ
			      C 				CheckAlign		dest
			      C 				VPXORQ			ZMM31, ZMM31, ZMM31
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				VPXORQ			YMM4, YMM4, YMM4
			      C 				FOR				idx, < 0, 4 >
			      C 				VMOVDQA64		YM_PTR [ dest ] [ idx * 8 ], YMM4
			      C 				ENDM
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				PXOR			XMM4, XMM4
			      C 				FOR				idx, < 0, 2, 4, 6 >
			      C 				MOVDQA			XM_PTR [ dest ] [ idx * 8 ], XMM4
			      C 				ENDM		
			      C 	ELSE
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Zero512Q		MACRO			dest:REQ
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C Copy512			MACRO			dest:REQ, src:REQ
			      C 	IF		__UseZ 
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		YMM4, YM_PTR [ src + 0 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			      C 				VMOVDQA64		YMM5, YM_PTR [ src ] [ 4 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 0 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 0 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 2 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 2 * 8 ], XMM3
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 4 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 4 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 6 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 6 * 8 ], XMM3
			      C 	ELSE
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Copy512Q		MACRO			dest:REQ, src:REQ
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ENDIF	; IFNDEF			ui512aMacros_INC
			      C 
								OPTION			casemap:none

 00000000			ui512D			SEGMENT			'DATA'	ALIGN (64)					; Declare a data segment	
								MemConstants										; Generate memory resident constants
 00000000  00000008 [	     1	qOnes			QWORD           8 DUP (0ffffffffffffffffh)
	    FFFFFFFFFFFFFFFF
	   ]
 00000040		     1	zeroQ			DQ				0
	   0000000000000000
 = 00000000		     1	retcode_zero	EQU				0
 = 00000001		     1	retcode_one		EQU				1
 =-00000001		     1	retcode_neg_one	EQU				-1
 00000048 00000000	     1	ret_zero		DD				retcode_zero						
 0000004C 00000001	     1	ret_one			DD				retcode_one
 00000050 FFFFFFFF	     1	ret_neg_one		DD				retcode_neg_one
 00000054 01		     1	mskB0			DB				1
 00000055 02		     1	mskB1			DB				2
 00000056 04		     1	mskB2			DB				4
 00000057 08		     1	mskB3			DB				8
 00000058 10		     1	mskB4			DB				16
 00000059 20		     1	mskB5			DB				32
 0000005A 40		     1	mskB6			DB				64
 0000005B 80		     1	mskB7			DB				128
 0000005C FF		     1	mskAll8			DB				255
 0000005D			ui512D			ENDS												; end of data segment

								VerifyRegs											; if option is turned on (in included macros file),
 00000000		     2	ui512			SEGMENT			PARA 'CODE'
 00000000  00000006 [	     2					DB				6 DUP (0cch)
	    CC
	   ]
 00000010		     2	reg_verify			PROC			FRAME
 00000010  4C/ 89 21	     1					MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
 00000013  4C/ 89 69 08	     1					MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
 00000017  4C/ 89 71 10	     1					MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
 0000001B  4C/ 89 79 18	     1					MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
 0000001F  48/ 89 79 20	     1					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
 00000023  48/ 89 71 28	     1					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RSI
 00000027  48/ 89 59 30	     1					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RBX
 0000002B  48/ 89 69 38	     1					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RBP
 0000002F  48/ 89 61 40	     1					MOV				Q_PTR [ RCX ] [ 8 * 8 ], RSP
 00000033  C3		     1					RET
 00000034		     2	reg_verify			ENDP
 00000034		     2	ui512			ENDS
																					; generate a debug routine for register integrity validation

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			zero_u		-	fill supplied 512bit (8 QWORDS) with zero
				;			Prototype:		extern "C" void zero_u ( u64* destarr );
				;			destarr		-	Address of destination 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			returns		-	nothing
				;
								Leaf_Entry		zero_u, ui512						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 00000034		     1	ui512			SEGMENT			PARA 'CODE'
 00000034  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000040		     1	zero_u			PROC			FRAME
								Zero512			RCX									; Zero 512 bit space addressed in RCX (the parameter)
 00000040  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000046  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000004C  C3							RET	
								Leaf_End		zero_u, ui512						; end of proc, end of section
 0000004D		     1	zero_u			ENDP
 0000004D		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			copy_u		-	copy supplied 512bit (8 QWORDS) source to supplied destination
				;			Prototype:		extern "C" void copy_u( u64* destarr, u64* srcarr )
				;			destarr		-	Address of destination 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			srcarr		-	Address of source 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			returns		-	nothing
				;
								Leaf_Entry		copy_u, ui512						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 0000004D		     1	ui512			SEGMENT			PARA 'CODE'
 0000004D  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000060		     1	copy_u			PROC			FRAME
								Copy512			RCX, RDX							; Copy 512 bit space from src array (address in RDX) to dest (RCX)
 00000060  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 00000066  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000006C  C3							RET	
								Leaf_End		copy_u, ui512						; end of proc, end of section
 0000006D		     1	copy_u			ENDP
 0000006D		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			set_uT64	-	set supplied destination 512 bit to supplied u64 value
				;			Prototype:		extern "C" void set_uT64( u64* destarr, u64 value )
				;			destarr		-	Address of destination 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			src			-	u64 value in RDX
				;			returns		-	nothing
				;
								Leaf_Entry		set_uT64, ui512						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 0000006D		     1	ui512			SEGMENT			PARA 'CODE'
 0000006D  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000080		     1	set_uT64			PROC			FRAME

					IF __UseZ
 00000080  C5 F9/ 90 0D						KMOVB			k1, mskB7
	   0000005B R
 00000088  62 62 FD C9/ 7C					VPBROADCASTQ 	ZMM31 {k1}{z}, RDX					; load parameter, zeroing all other qwords
	   FA
 0000008E  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [ RCX ], ZMM31				; store at destination
	   39

					ELSE
					ENDIF
 00000094  C3							RET	
								Leaf_End		set_uT64, ui512						; end of proc, end of section
 00000095		     1	set_uT64			ENDP
 00000095		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			compare_u	-	unsigned compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
				;			Prototype:		extern "C" s32 compare_u( u64* lh_op, u64* rh_op )
				;			lh_op		-	Address of LH 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			rh_op		-	Address of RH 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			returns		-	(0) for equal, -1 for lh_op is less than rh_op, 1 for lh_op is greater than rh_op 
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore
				;
								Leaf_Entry		compare_u, ui512					; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 00000095		     1	ui512			SEGMENT			PARA 'CODE'
 00000095  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000000A0		     1	compare_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX

					IF __UseZ
 000000A0  62 61 FD 48/ 6F					VMOVDQA64		ZMM30, ZM_PTR [ RCX ]				; Load parameters
	   31
 000000A6  62 61 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000000AC  62 93 8D 40/ 1E					VPCMPUQ			k1, ZMM30, ZMM31, CPLT				; in-lane compare 8 words for 'less than'
	   CF 01
 000000B3  62 93 8D 40/ 1E					VPCMPUQ			k2, ZMM30, ZMM31, CPGT				; do the same for 'greater than' (interleave these two compares to hide latencies)
	   D7 06
 000000BA  C5 78/ 93 C1						KMOVW			R8D, k1
 000000BE  C5 F8/ 93 C2						KMOVW			EAX, k2
 000000C2  41/ 81 C8						OR				R8D, MASK kMask.b8					; OR in a high bit to make an equal compare not zero	
	   00000100
 000000C9  0D 00000100						OR				EAX, MASK kMask.b8
 000000CE  41/ D1 E0						SHL				R8D, 1								; shift to get bits 2 through 8
 000000D1  D1 E0						SHL				EAX, 1
						IF __UseBMI2
 000000D3  F3/ 45/ 0F BC C0					TZCNT			R8D, R8D							; get bit number of right-most (most significant) 1 thru 8
 000000D8  F3/ 0F BC C0						TZCNT			EAX, EAX
						ELSE		
						ENDIF
 000000DC  44/ 3B C0						CMP				R8D, EAX							; compare: which is most significant? LT or GT? (or zero - equal)
 000000DF  8D 04 25						LEA				EAX, [ 0 ]
	   00000000
 000000E6  0F 47 05						CMOVA			EAX, ret_one
	   0000004C R
 000000ED  0F 42 05						CMOVB			EAX, ret_neg_one
	   00000050 R
 000000F4  C3							RET

					ELSEIF	__UseY
					ENDIF
								Leaf_End		compare_u, ui512					; end of proc, end of section 
 000000F5		     1	compare_u			ENDP
 000000F5		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			compare_uT64-	unsigned compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand
				;			Prototype:		extern "C" s32 compare_uT64( u64* lh_op, u64 rh_op )
				;			lh_op		-	Address of LH 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			rh_op		-	The RH 64-bit value in RDX
				;			returns		-	(0) for equal, -1 for less than, 1 for greater than
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore
				;
								Leaf_Entry		compare_uT64, ui512					; Declare code section, public proc, no prolog, no frame, exceptions handled by caller				
 000000F5		     1	ui512			SEGMENT			PARA 'CODE'
 000000F5  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000100		     1	compare_uT64			PROC			FRAME
								CheckAlign		RCX

					IF		__UseZ
 00000100  62 61 FD 48/ 6F					VMOVDQA64		ZMM30, ZM_PTR [ RCX ]				; Load lh-op parameter
	   31
 00000106  C5 F9/ 90 0D						KMOVB			k1, mskB7
	   0000005B R
 0000010E  62 62 FD C9/ 7C					VPBROADCASTQ 	ZMM31 {k1}{z}, RDX					; load rh_op parameter (both now in Z regs)
	   FA
 00000114  62 93 8D 40/ 1E					VPCMPUQ			k1, ZMM30, ZMM31, CPLT				; in-lane compare for LT
	   CF 01
 0000011B  62 93 8D 40/ 1E					VPCMPUQ			k2, ZMM30, ZMM31, CPGT				; do the same for 'greater than'
	   D7 06
 00000122  C5 78/ 93 C1						KMOVW			R8D, k1
 00000126  C5 F8/ 93 C2						KMOVW			EAX, k2
 0000012A  41/ 81 C8						OR				R8D, MASK kMask.b8					; OR in a high bit to make an equal compare not zero	
	   00000100
 00000131  0D 00000100						OR				EAX, MASK kMask.b8
 00000136  41/ D1 E0						SHL				R8D, 1								; shift to get bits 2 through 8
 00000139  D1 E0						SHL				EAX, 1
						IF __UseBMI2
 0000013B  F3/ 45/ 0F BC C0					TZCNT			R8D, R8D							; get bit number of right-most (most significant) 1 thru 8
 00000140  F3/ 0F BC C0						TZCNT			EAX, EAX
						ELSE
						ENDIF
 00000144  44/ 3B C0						CMP				R8D, EAX							; compare: which is most significant? LT or GT? (or zero - equal)
 00000147  8D 04 25						LEA				EAX, [ retcode_zero ]
	   00000000
 0000014E  0F 47 05						CMOVA			EAX, ret_one
	   0000004C R
 00000155  0F 42 05						CMOVB			EAX, ret_neg_one
	   00000050 R
 0000015C  C3							RET

					ELSE
					ENDIF
								Leaf_End		compare_uT64, ui512					; end of proc, end of section
 0000015D		     1	compare_uT64			ENDP
 0000015D		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			add_u		-	unsigned add supplied 512bit (8 QWORDS) sources to supplied destination
				;			Prototype:		extern "C" s32 add_u( u64* sum, u64* addend1, u64* addend2 )
				;			sum			-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			addend1		-	Address of  the 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			addend2		-	Address of  the 64 byte aligned array of 8 64-bit QWORDS (512 bits) in R8
				;			returns		-	zero for no carry, 1 for carry (overflow)
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore
				;
								Leaf_Entry		add_u, ui512						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 0000015D		     1	ui512			SEGMENT			PARA 'CODE'
 0000015D  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000170		     1	add_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8	

				     IF __UseZ
				; Load operands
 00000170  62 61 FD 48/ 6F	                VMOVDQA64		ZMM30, ZM_PTR [ RDX ]				; Load addend1 (lh_op)
	   32
 00000176  62 41 FD 48/ 6F	                VMOVDQA64		ZMM31, ZM_PTR [ R8 ]				; Load addend2 (rh_op)
	   38

				; Initialize: R9=1 for carry-add; K7=0 for carry done mask
 0000017C  4D/ 33 C9		                XOR				R9, R9
 0000017F  49/ FF C1		                INC				R9
 00000182  C5 C5/ 47 FF		                KXORB			k7, k7, k7							; Clear k7 (what carries have been done mask)

				; Initial addition and carry computation (interleaved for pipeline)
 00000186  62 01 8D 40/ D4	                VPADDQ			ZMM29, ZMM30, ZMM31					; Initial sum, lane by lane add
	   EF
 0000018C  62 93 95 40/ 1E	                VPCMPUQ			k1, ZMM29, ZMM30, CPLT				; Initial carries: sum[i] < lh_op[i] (unsigned carry detect, lane by lane)
	   CE 01

				; Carry propagation (loop until done) Note: tried unrolled here, but code size, hence instruction pipeline fetch, slower than tight loop
 00000193			@@:
 00000193  C5 C5/ 42 D1		                KANDNB			k2, k7, k1							; eliminate apparent carries if they had already been flagged (and processed) (AND NOT previous K7)
 00000197  C5 C5/ 45 FA		                KORB			k7, k7, k2							; new carries in K2, OR into carries done (K7)
 0000019B  C4 E3 79/ 30 DA	                KSHIFTRB		k3, k2, 1							; new carries shift right to align which lane to add carry to
	   01
 000001A1  C5 F9/ 99 DB		                KTESTB			k3, k3								; no new carries? exit
 000001A5  74 15		                JZ				@@saveexit
 000001A7  62 42 FD CB/ 7C	                VPBROADCASTQ	ZMM28 {k3}{z}, R9					; in scatch reg, zero lane, load shifted carry lanes with '1'
	   E1
 000001AD  62 01 95 43/ D4	                VPADDQ			ZMM29 {k3}, ZMM29, ZMM28			; add in the carries
	   EC
 000001B3  62 93 95 43/ 1E	                VPCMPUQ			k1 {k3}, ZMM29, ZMM28, CPLT			; compare result, lane by lane, to see if less than orginal (indicating an overflow / carry)
	   CC 01
 000001BA  EB D7						JMP				@B									; check for additional (newly generated) carries

				; Complete, extract carry out (overflow) for return code, store result sum at callers sum
 000001BC			@@saveexit:
 000001BC  C5 F9/ 93 C7		                KMOVB			RAX, k7								; Move final carries done to RAX
 000001C0  48/ 83 E0 01		                AND				RAX, 1								; bit 0 (MSB carry-out)
 000001C4  62 61 FD 48/ 7F	                VMOVDQA64		ZM_PTR [ RCX ], ZMM29				; Store sum
	   29
 000001CA  C3			                RET

				 	ELSE
					ENDIF
								Leaf_End		add_u, ui512						; end of proc, end of section
 000001CB		     1	add_u			ENDP
 000001CB		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			add_uT64	-	add supplied 64bit QWORD (value) to 512bit (8 QWORDS), place in supplied destination
				;			Prototype:		extern "C" s32 add_uT64( u64* sum, u64* addend1, u64 addend2 )
				;			sum			-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			addend1		-	Address of  the 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			addend2		-	The 64-bit value in R8
				;			returns		-	zero for no carry, 1 for carry (overflow)
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore
				;
								Leaf_Entry		add_uT64, ui512						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 000001CB		     1	ui512			SEGMENT			PARA 'CODE'
 000001CB  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000001E0		     1	add_uT64			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX

					IF __UseZ
				; Load operands				
 000001E0  62 61 FD 48/ 6F					VMOVDQA64		ZMM30, ZM_PTR [RDX]					; ZMM30 = addend1 (8 QWORDs)
	   32
 000001E6  C5 F9/ 90 0D						KMOVB			k1, mskB7							; mask for least significant word
	   0000005B R
 000001EE  62 42 FD C9/ 7C					VPBROADCASTQ	ZMM31 {k1}{z}, R8					; ZMM31 now 512 bit version of passed addend2
	   F8

				; Initialize: R9=1 for carry-add; K7=0 for carry done mask
 000001F4  4D/ 33 C9		                XOR				R9, R9
 000001F7  49/ FF C1		                INC				R9
 000001FA  C5 C5/ 47 FF		                KXORB			k7, k7, k7							; Clear k7 (what carries have been done mask)

				; Initial addition and carry computation (interleaved for pipeline)
 000001FE  62 01 8D 40/ D4	                VPADDQ			ZMM29, ZMM30, ZMM31					; Initial sum, lane by lane add
	   EF
 00000204  62 93 95 40/ 1E	                VPCMPUQ			k1, ZMM29, ZMM30, CPLT				; Initial carries: sum[i] < lh_op[i] (unsigned carry detect, lane by lane)
	   CE 01

				; Carry propagation (loop until done) Note: tried unrolled here, but code size, hence instruction pipeline fetch, slower than tight loop
 0000020B			@@:
 0000020B  C5 C5/ 42 D1		                KANDNB			k2, k7, k1							; eliminate apparent carries if they had already been flagged (and processed) (AND NOT previous K7)
 0000020F  C5 C5/ 45 FA		                KORB			k7, k7, k2							; new carries in K2, OR into carries done (K7)
 00000213  C4 E3 79/ 30 DA	                KSHIFTRB		k3, k2, 1							; new carries shift right to align which lane to add carry to
	   01
 00000219  C5 F9/ 99 DB		                KTESTB			k3, k3								; no new carries? exit
 0000021D  74 15		                JZ				@@saveexit
 0000021F  62 42 FD CB/ 7C	                VPBROADCASTQ	ZMM28 {k3}{z}, R9					; in scatch reg, zero lane, load shifted carry lanes with '1'
	   E1
 00000225  62 01 95 43/ D4	                VPADDQ			ZMM29 {k3}, ZMM29, ZMM28			; add in the carries
	   EC
 0000022B  62 93 95 43/ 1E	                VPCMPUQ			k1 {k3}, ZMM29, ZMM28, CPLT			; compare result, lane by lane, to see if less than orginal (indicating an overflow / carry)
	   CC 01
 00000232  EB D7						JMP				@B									; check for additional (newly generated) carries

				; Complete, extract carry out (overflow) for return code, store result sum at callers sum
 00000234			@@saveexit:
 00000234  C5 F9/ 93 C7		                KMOVB			RAX, k7								; Move final carries done to RAX
 00000238  48/ 83 E0 01		                AND				RAX, retcode_one					; bit 0 (MSB carry-out)
 0000023C  62 61 FD 48/ 7F	                VMOVDQA64		ZM_PTR [ RCX ], ZMM29				; Store sum
	   29
 00000242  C3			                RET													; EAX carries return code (from carry computation above)

					ELSE
					ENDIF
								Leaf_End		add_uT64, ui512						; end of proc, end of section 
 00000243		     1	add_uT64			ENDP
 00000243		     1	ui512			ENDS
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			sub_u		-	subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
				;			Prototype:		extern "C" s32 sub_u( u64* difference, u64* left operand, u64* right operand )
				;			difference	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of the LHOP 8 64-bit QWORDS (512 bits) in RDX
				;			rh_op		-	Address of the RHOP 8 64-bit QWORDS (512 bits) in R8
				;			returns		-	zero for no borrow, 1 for borrow (underflow)
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore
				;
								Leaf_Entry		sub_u, ui512						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 00000243		     1	ui512			SEGMENT			PARA 'CODE'
 00000243  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000250		     1	sub_u			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8

					IF __UseZ
				; Load operands
 00000250  62 61 FD 48/ 6F					VMOVDQA64		ZMM30, ZM_PTR [RDX]					; Load lh_op
	   32
 00000256  62 41 FD 48/ 6F					VMOVDQA64		ZMM31, ZM_PTR [R8]					; Load rh_op
	   38

				; Initialize loop variables: R9 for the targeted in-lane subtract of borrows; RAX for return code overall borrow flag
 0000025C  4D/ 33 C9						XOR				R9, R9
 0000025F  49/ FF C1						INC				R9
 00000262  48/ 33 C0						XOR				RAX, RAX
 00000265  C5 C5/ 47 FF						KXORB			k7, k7, k7							; Clear k7 (what borrows have been done mask)

				; Initial subtraction
 00000269  62 01 8D 40/ FB					VPSUBQ		    ZMM29, ZMM30, ZMM31					; Initial subtraction
	   EF
 0000026F  62 93 8D 40/ 1E					VPCMPUQ		    k1, ZMM30, ZMM31, CPLT				; Initial borrows
	   CF 01

				; Examine computed borrows: 
 00000276			@@:
 00000276  C5 C5/ 42 D1		                KANDNB			k2, k7, k1							; eliminate apparent borrows if they had already been flagged (and processed) (AND NOT previous K7)
 0000027A  C5 C5/ 45 FA		                KORB			k7, k7, k2							; new borrows in K2, OR into borrows done (K7)
 0000027E  C4 E3 79/ 30 DA	                KSHIFTRB		k3, k2, 1							; new borrows shift right to align which lane to add borrow from
	   01
 00000284  C5 F9/ 99 DB		                KTESTB			k3, k3								; no new borrows? exit
 00000288  74 15						JZ				@@saveexit							; If, after alignment shift, there are no borrows, save and exit

				; anything else, and for as long as these subtractions cause borrows, subtract one from each borrowed from SIMD lane
 0000028A  62 42 FD CB/ 7C					VPBROADCASTQ	ZMM28 {k3}{z}, R9					; Apply borrow-ins only where needed
	   E1
 00000290  62 01 95 43/ FB					VPSUBQ			ZMM29 {k3}, ZMM29, ZMM28
	   EC
 00000296  62 93 95 43/ 1E					VPCMPUQ			k1 { k3 }, ZMM29, ZMM28, CPGT		; compute new mask of borrows
	   CC 06
 0000029D  EB D7						JMP				@B
 0000029F			@@saveexit:
 0000029F  C5 F9/ 93 C7		                KMOVB			RAX, k7								; Move final borrows done to RAX
 000002A3  48/ 83 E0 01		                AND				RAX, retcode_one					; bit 0 (MSB borrow-out)
 000002A7  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [RCX], ZMM29
	   29
 000002AD  C3							RET

					ELSE
					ENDIF
								Leaf_End		sub_u, ui512						; end of proc, end of section 
 000002AE		     1	sub_u			ENDP
 000002AE		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			sub_uT64	-	subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
				;			Prototype:		extern "C" s32 sub_uT64( u64* difference, u64* left operand, u64 right operand )
				;			difference	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of  the 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			rh_op		-	64-bitvalue in R8
				;			returns		-	zero for no borrow, 1 for borrow (underflow)
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore
				;
								Leaf_Entry		sub_uT64, ui512						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 000002AE		     1	ui512			SEGMENT			PARA 'CODE'
 000002AE  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000002C0		     1	sub_uT64			PROC			FRAME
								CheckAlign		RCX
								CheckAlign		RDX

					IF __UseZ
				; Load operands
 000002C0  62 61 FD 48/ 6F					VMOVDQA64		ZMM30, ZM_PTR [RDX]			        ; Load lh_op
	   32
 000002C6  C5 F9/ 90 0D						KMOVB			k1, mskB7							; mask for least significant word
	   0000005B R
 000002CE  62 42 FD C9/ 7C					VPBROADCASTQ	ZMM31 {k1}{z}, R8					; ZMM31 now 512 bit version of passed rh_op
	   F8

				; Initialize loop variables: R9 for the targeted in-lane subtract of borrows; RAX for return code overall borrow flag
 000002D4  4D/ 33 C9						XOR				R9, R9
 000002D7  49/ FF C1						INC				R9
 000002DA  48/ 33 C0						XOR				RAX, RAX
 000002DD  C5 C5/ 47 FF						KXORB			k7, k7, k7							; Clear k7 (what borrows have been done mask)

				; Initial subtraction
 000002E1  62 01 8D 40/ FB					VPSUBQ		    ZMM29, ZMM30, ZMM31					; Initial subtraction
	   EF
 000002E7  62 93 8D 40/ 1E					VPCMPUQ		    k1, ZMM30, ZMM31, CPLT				; Initial borrows
	   CF 01

				; Examine computed borrows: 
 000002EE			@@:
 000002EE  C5 C5/ 42 D1		                KANDNB			k2, k7, k1							; eliminate apparent borrows if they had already been flagged (and processed) (AND NOT previous K7)
 000002F2  C5 C5/ 45 FA		                KORB			k7, k7, k2							; new borrows in K2, OR into borrows done (K7)
 000002F6  C4 E3 79/ 30 DA	                KSHIFTRB		k3, k2, 1							; new borrows shift right to align which lane to add borrow from
	   01
 000002FC  C5 F9/ 99 DB		                KTESTB			k3, k3								; no new borrows? exit
 00000300  74 15						JZ				@@saveexit							; If, after alignment shift, there are no borrows, save and exit

				; anything else, and for as long as these subtractions cause borrows, subtract one from each borrowed from SIMD lane
 00000302  62 42 FD CB/ 7C					VPBROADCASTQ	ZMM28 {k3}{z}, R9					; Apply borrow-ins only where needed
	   E1
 00000308  62 01 95 43/ FB					VPSUBQ			ZMM29 {k3}, ZMM29, ZMM28
	   EC
 0000030E  62 93 95 43/ 1E					VPCMPUQ			k1 { k3 }, ZMM29, ZMM28, CPGT		; compute new mask of borrows
	   CC 06
 00000315  EB D7						JMP				@B
 00000317			@@saveexit:
 00000317  C5 F9/ 93 C7		                KMOVB			RAX, k7								; Move final borrows done to RAX
 0000031B  48/ 83 E0 01		                AND				RAX, retcode_one					; bit 0 (MSB borrow-out)
 0000031F  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [RCX], ZMM29
	   29
 00000325  C3							RET

					ELSE
					ENDIF
								Leaf_End		sub_uT64, ui512						; end of proc, end of section
 00000326		     1	sub_uT64			ENDP
 00000326		     1	ui512			ENDS

					END
Microsoft (R) Macro Assembler (x64) Version 14.44.35214.0   08/16/25 23:41:38
ui512a.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckAlign . . . . . . . . . . .	Proc
Copy512Q . . . . . . . . . . . .	Proc
Copy512  . . . . . . . . . . . .	Proc
Leaf_End . . . . . . . . . . . .	Proc
Leaf_Entry . . . . . . . . . . .	Proc
MemConstants . . . . . . . . . .	Proc
VerifyRegs . . . . . . . . . . .	Proc
Zero512Q . . . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

kMask  . . . . . . . . . . . . .	 00000009      00000009
  b8 . . . . . . . . . . . . . .	 00000008      00000001	     0100     ?
  b7 . . . . . . . . . . . . . .	 00000007      00000001	     0080     ?
  b6 . . . . . . . . . . . . . .	 00000006      00000001	     0040     ?
  b5 . . . . . . . . . . . . . .	 00000005      00000001	     0020     ?
  b4 . . . . . . . . . . . . . .	 00000004      00000001	     0010     ?
  b3 . . . . . . . . . . . . . .	 00000003      00000001	     0008     ?
  b2 . . . . . . . . . . . . . .	 00000002      00000001	     0004     ?
  b1 . . . . . . . . . . . . . .	 00000001      00000001	     0002     ?
  b0 . . . . . . . . . . . . . .	 00000000      00000001	     0001     ?


Types:

                N a m e                  Size     Attr

LPVOID . . . . . . . . . . . . .	 00000008     PTR VOID


Segments:

                N a m e                  Length   Align   Class

ui512D . . . . . . . . . . . . .	 0000005D 64	  'DATA'	
ui512  . . . . . . . . . . . . .	 00000326 16	  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

add_uT64 . . . . . . . . . . . .	P 	 000001E0 ui512	Length= 00000063 Public
  @@saveexit . . . . . . . . . .	L 	 00000234 ui512	
add_u  . . . . . . . . . . . . .	P 	 00000170 ui512	Length= 0000005B Public
  @@saveexit . . . . . . . . . .	L 	 000001BC ui512	
compare_uT64 . . . . . . . . . .	P 	 00000100 ui512	Length= 0000005D Public
compare_u  . . . . . . . . . . .	P 	 000000A0 ui512	Length= 00000055 Public
copy_u . . . . . . . . . . . . .	P 	 00000060 ui512	Length= 0000000D Public
reg_verify . . . . . . . . . . .	P 	 00000010 ui512	Length= 00000024 Public
set_uT64 . . . . . . . . . . . .	P 	 00000080 ui512	Length= 00000015 Public
sub_uT64 . . . . . . . . . . . .	P 	 000002C0 ui512	Length= 00000066 Public
  @@saveexit . . . . . . . . . .	L 	 00000317 ui512	
sub_u  . . . . . . . . . . . . .	P 	 00000250 ui512	Length= 0000005E Public
  @@saveexit . . . . . . . . . .	L 	 0000029F ui512	
zero_u . . . . . . . . . . . . .	P 	 00000040 ui512	Length= 0000000D Public


Symbols:

                N a m e                 Type     Value    Attr

$xdatasym  . . . . . . . . . . .	Byte	 00000000 _XDATA	
B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPFALSE  . . . . . . . . . . . .	Number	 00000003h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
CPTRUE . . . . . . . . . . . . .	Number	 00000007h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__CheckAlign . . . . . . . . . .	Number	 00000000h   
__UseBMI2  . . . . . . . . . . .	Number	 00000001h   
__UseQ . . . . . . . . . . . . .	Number	 00000000h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000001h   
__VerifyRegs . . . . . . . . . .	Number	 00000001h   
compile_time_options_INC . . . .	Text   	 1
legalnotes . . . . . . . . . . .	Number	 00000001h   
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
mskAll8  . . . . . . . . . . . .	Byte	 0000005C ui512D	
mskB0  . . . . . . . . . . . . .	Byte	 00000054 ui512D	
mskB1  . . . . . . . . . . . . .	Byte	 00000055 ui512D	
mskB2  . . . . . . . . . . . . .	Byte	 00000056 ui512D	
mskB3  . . . . . . . . . . . . .	Byte	 00000057 ui512D	
mskB4  . . . . . . . . . . . . .	Byte	 00000058 ui512D	
mskB5  . . . . . . . . . . . . .	Byte	 00000059 ui512D	
mskB6  . . . . . . . . . . . . .	Byte	 0000005A ui512D	
mskB7  . . . . . . . . . . . . .	Byte	 0000005B ui512D	
qOnes  . . . . . . . . . . . . .	QWord	 00000000 ui512D	
ret_neg_one  . . . . . . . . . .	DWord	 00000050 ui512D	
ret_one  . . . . . . . . . . . .	DWord	 0000004C ui512D	
ret_zero . . . . . . . . . . . .	DWord	 00000048 ui512D	
retcode_neg_one  . . . . . . . .	Number	 -00000001h   
retcode_one  . . . . . . . . . .	Number	 00000001h   
retcode_zero . . . . . . . . . .	Number	 00000000h   
ui512aMacros_INC . . . . . . . .	Text   	 1
zeroQ  . . . . . . . . . . . . .	QWord	 00000040 ui512D	

	   0 Warnings
	   0 Errors

Microsoft (R) Macro Assembler (x64) Version 14.43.34808.0   03/03/25 23:14:25
ui512a.asm						     Page 1 - 1


				;
				;			ui512a
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			File:			ui512a.asm
				;			Author:			John G. Lynch
				;			Legal:			Copyright @2024, per MIT License below
				;			Date:			May 13, 2024
				;
				;			Notes:
				;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
				;
				;				ui512a provides basic operations: zero, copy, compare, add, subtract.
				;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
				;               ui512md provides multiply and divide.
				;
				;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
				;				(currently using VS Community 2022 17.9.6)
				;
				;				It provides external signatures that allow linkage to C and C++ programs,
				;				where a shell/wrapper could encapsulate the methods as part of an object.
				;
				;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
				;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
				;
				;				If processor extensions are used, the caller must align the variables declared and passed
				;				on the appropriate byte boundary (e.g. alignas 64 for 512)
				;
				;				This module is very light-weight (less than 1K bytes) and relatively fast,
				;				but is not intended for all processor types or all environments. 
				;
				;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects is all it is meant to be.
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			MIT License
				;
				;			Copyright (c) 2024 John G. Lynch
				;
				;				Permission is hereby granted, free of charge, to any person obtaining a copy
				;				of this software and associated documentation files (the "Software"), to deal
				;				in the Software without restriction, including without limitation the rights
				;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
				;				copies of the Software, and to permit persons to whom the Software is
				;				furnished to do so, subject to the following conditions:
				;
				;				The above copyright notice and this permission notice shall be included in all
				;				copies or substantial portions of the Software.
				;
				;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
				;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
				;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
				;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
				;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
				;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
				;				SOFTWARE.
				;
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------

								INCLUDE			ui512aMacros.inc
			      C .nolist
			      C .list
			      C IFNDEF			ui512aMacros_INC
 = 1			      C ui512aMacros_INC EQU		<1>
			      C 
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512a.asm)
			      C 
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF		zero_u:PROC
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF		copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF		set_uT64:PROC
			      C 
			      C ;	// s16 compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_u:PROC
			      C 
			      C ;	// s16 compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_uT64:PROC
			      C 
			      C ;	// s16 add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u:PROC
			      C 
			      C ;	// s16 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_uT64:PROC
			      C 
			      C ;	// s16 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u:PROC
			      C 
			      C ;	// s16 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_uT64:PROC
			      C 
			      C ;			Configuration choices
 = 00000000		      C __UseZ			EQU				0									; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY			EQU				0									; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX			EQU				0									; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000001		      C __UseQ			EQU				1									; Do not use extensions, use standard x64 bit registers and instructions
			      C ;
 = 00000000		      C __CheckAlign	EQU				0									; User is expected to pass arguments aligned on 64 byte boundaries, 
			      C 																	; This setting enforces that with a check. It should not be necessary, but included to help debugging
			      C 
			      C ;           Some coding shortcuts
 = ZMMWORD PTR		      C ZM_PTR			EQU				ZMMWORD PTR
 = YMMWORD PTR		      C YM_PTR			EQU				YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR			EQU				XMMWORD PTR
 = QWORD PTR		      C Q_PTR			EQU				QWORD PTR
 = DWORD PTR		      C D_PTR			EQU				DWORD PTR
 = WORD PTR		      C W_PTR			EQU				WORD PTR
 = BYTE PTR		      C B_PTR			EQU				BYTE PTR
 = DWORD BCST		      C m32BCST			EQU				DWORD BCST
 = QWORD BCST		      C m64BCST			EQU				QWORD BCST
			      C 
			      C ;			mask codes (for compares using instructions like VPCMPUQ)
 = 00000000		      C CPEQ			EQU				0
 = 00000001		      C CPLT			EQU				1
 = 00000002		      C CPLE			EQU				2
 = 00000003		      C CPFALSE			EQU				3
 = 00000004		      C CPNE			EQU				4
 = 00000005		      C CPGE			EQU				5
 = 00000006		      C CPGT			EQU				6
 = 00000007		      C CPTRUE			EQU				7
			      C 
			      C ;			Mask values (for k reg) used to select particulare QWORDS from X, Y, or Z simd regs
 = 00000001		      C MaskBit0		EQU				B_PTR [ 00000001b ]
 = 00000002		      C MaskBit1		EQU				B_PTR [ 00000010b ]
 = 00000004		      C MaskBit2		EQU				B_PTR [ 00000100b ]
 = 00000008		      C MaskBit3		EQU				B_PTR [ 00001000b ]
 = 00000010		      C MaskBit4		EQU				B_PTR [ 00010000b ]
 = 00000020		      C MaskBit5		EQU				B_PTR [ 00100000b ]
 = 00000040		      C MaskBit6		EQU				B_PTR [ 01000000b ]
 = 00000080		      C MaskBit7		EQU				B_PTR [ 10000000b ]
			      C 
 = 			      C Mask20			EQU
			      C ;==========================================================================================
			      C ;           Notes on x64 calling conventions        aka "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address
			      C ; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;===========================================================================================
			      C ;
			      C ;===========================================================================================
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile,
			      C ;	and do not need to be saved
			      C ;  ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C ;===========================================================================================
			      C 
			      C 
			      C ;===========================================================================================
			      C ;          Local macros
			      C ;===========================================================================================
			      C 
			      C ;
			      C ;			Test passed variable addresses for 64 byte alignment
			      C ;			Note: Better performance if this is off, but for debugging, maybe have it on
			      C ;
			      C 
			      C CheckAlign		MACRO			Raddr
			      C 				LOCAL			ok
			      C 	IF	__CheckAlign
			      C 				TEST			Raddr, 63							; Is specified param aligned 64?
			      C 				JZ				ok									; Yes, passes test, continue
			      C 				INT				0									; No, fails, break (can substitute other exception handling)
			      C ok:
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C MemConstants	MACRO
			      C ;		Return codes commonly used.			
			      C ret0			DD				0								
			      C ret1			DD				1
			      C ret_1			DD				-1
			      C ;		Masks commonly used
			      C mskAll8			DB				255
			      C mskB0			DB				1
			      C mskB1			DB				2
			      C mskB2			DB				4
			      C mskB3			DB				8
			      C mskB4			DB				16
			      C mskB5			DB				32
			      C mskB6			DB				64
			      C mskB7			DB				128
			      C mskHex100		DD				0100h
			      C 				ENDM
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C 
			      C Zero512			MACRO			dest
			      C 				CheckAlign		dest
			      C 	IF	__UseZ
			      C 				VPXORQ			ZMM31, ZMM31, ZMM31
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				VPXORQ			YMM4, YMM4, YMM4
			      C 				VMOVDQA64		YM_PTR [ dest + 0 * 8 ], YMM4
			      C 				VMOVDQA64		YM_PTR [ dest + 4 * 8 ], YMM4
			      C 	ELSEIF	__UseX
			      C 				PXOR			XMM4, XMM4
			      C 				MOVDQA			XM_PTR [ dest + 0 * 8 ], XMM4
			      C 				MOVDQA			XM_PTR [ dest + 2 * 8 ], XMM4
			      C 				MOVDQA			XM_PTR [ dest + 4 * 8 ], XMM4
			      C 				MOVDQA			XM_PTR [ dest + 6 * 8 ], XMM4			
			      C 	ELSE
			      C 				XOR				RAX, RAX
			      C 				MOV				[ dest + 0 * 8 ], RAX
			      C 				MOV				[ dest + 1 * 8 ], RAX
			      C 				MOV				[ dest + 2 * 8 ], RAX
			      C 				MOV				[ dest + 3 * 8 ], RAX
			      C 				MOV				[ dest + 4 * 8 ], RAX
			      C 				MOV				[ dest + 5 * 8 ], RAX
			      C 				MOV				[ dest + 6 * 8 ], RAX
			      C 				MOV				[ dest + 7 * 8 ], RAX
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C 
			      C Copy512			MACRO			dest, src
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 	IF	__UseZ
			      C 				VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				VMOVDQA64		YMM4, YM_PTR [ src + 0 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest + 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			      C 				VMOVDQA64		YMM5, YM_PTR [ src + 4 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest + 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 				MOVDQA			XMM4, XM_PTR [ src + 0 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest + 0 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src + 2 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest + 2 * 8 ], XMM3
			      C 				MOVDQA			XMM4, XM_PTR [ src + 4 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest + 4 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src + 6 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest + 6 * 8 ], XMM3
			      C 	ELSE
			      C 				MOV				RAX, [ src + 0 * 8 ]
			      C 				MOV				[ dest + 0 * 8 ], RAX
			      C 				MOV				RAX, [ src + 1 * 8 ]
			      C 				MOV				[ dest + 1 * 8 ], RAX
			      C 				MOV				RAX, [ src + 2 * 8 ]
			      C 				MOV				[ dest + 2 * 8 ], RAX
			      C 				MOV				RAX, [ src + 3 * 8 ]
			      C 				MOV				[ dest + 3 * 8 ], RAX
			      C 				MOV				RAX, [ src + 4 * 8 ]
			      C 				MOV				[ dest + 4 * 8 ], RAX
			      C 				MOV				RAX, [ src + 5 * 8 ]
			      C 				MOV				[ dest + 5 * 8 ], RAX
			      C 				MOV				RAX, [ src + 6 * 8 ]
			      C 				MOV				[ dest + 6 * 8 ], RAX
			      C 				MOV				RAX, [ src + 7 * 8 ]
			      C 				MOV				[ dest + 7 * 8 ], RAX
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Get a GP reg QWORD from within a Z register as specified by mask
			      C ;			Note: RAX, ZMM0 and k1 are used and not restored
			      C ;			Example usage: GetZatIdx R11, ZMM1, MaskBit2 or SetZatIdx ZMM1, R12, [ R9 ]  (where R9 is a bit mask, not an integer index)
			      C ;			Note: These are req to reg ops; no memory fetches (other than instructions from pipeline)
			      C ;
			      C 
			      C GetZatMask		MACRO			dest, src, mask
			      C 				LEA				RAX,  mask
			      C 				KMOVB			k1, RAX
			      C 				VPCOMPRESSQ		ZMM0 {k1}{z}, src
			      C 				VMOVQ			dest, XMM0
			      C 				ENDM
			      C 
			      C ;
			      C ;			Set a GP Reg QWORD within a Z register as specified by mask
			      C ;			Note: RAX and k1 are used and not restored
			      C ;			Example usage: SetZatIdx ZMM1, R8, MaskBit2
			      C ;			Note: These are req to reg ops; no memory fetches (other than instructions from pipeline)
			      C ;
			      C 
			      C SetZatMask		MACRO			dest, src, mask
			      C 				LEA				RAX, mask
			      C 				KMOVB			k1, RAX
			      C 				VPBROADCASTQ 	dest {k1}, src
			      C 				ENDM
			      C ENDIF
			      C 
								OPTION			casemap:none
 00000000			.CODE
								OPTION			PROLOGUE:none
								OPTION			EPILOGUE:none

								MemConstants
 00000000 00000000	     1	ret0			DD				0								
 00000004 00000001	     1	ret1			DD				1
 00000008 FFFFFFFF	     1	ret_1			DD				-1
 0000000C FF		     1	mskAll8			DB				255
 0000000D 01		     1	mskB0			DB				1
 0000000E 02		     1	mskB1			DB				2
 0000000F 04		     1	mskB2			DB				4
 00000010 08		     1	mskB3			DB				8
 00000011 10		     1	mskB4			DB				16
 00000012 20		     1	mskB5			DB				32
 00000013 40		     1	mskB6			DB				64
 00000014 80		     1	mskB7			DB				128
 00000015 00000100	     1	mskHex100		DD				0100h

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			zero_u		-	fill supplied 512bit (8 QWORDS) with zero
				;			Prototype:		extern "C" void zero_u ( u64* destarr );
				;			destarr		-	Address of destination 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			returns		-	nothing
				;

 00000019			zero_u			PROC			PUBLIC
								Zero512			RCX									; Zero 512 bit space addressed in RCX (the parameter)
 00000019  48/ 33 C0	     1					XOR				RAX, RAX
 0000001C  48/ 89 01	     1					MOV				[ RCX + 0 * 8 ], RAX
 0000001F  48/ 89 41 08	     1					MOV				[ RCX + 1 * 8 ], RAX
 00000023  48/ 89 41 10	     1					MOV				[ RCX + 2 * 8 ], RAX
 00000027  48/ 89 41 18	     1					MOV				[ RCX + 3 * 8 ], RAX
 0000002B  48/ 89 41 20	     1					MOV				[ RCX + 4 * 8 ], RAX
 0000002F  48/ 89 41 28	     1					MOV				[ RCX + 5 * 8 ], RAX
 00000033  48/ 89 41 30	     1					MOV				[ RCX + 6 * 8 ], RAX
 00000037  48/ 89 41 38	     1					MOV				[ RCX + 7 * 8 ], RAX
 0000003B  C3							RET		
 0000003C			zero_u			ENDP 

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			copy_u		-	copy supplied 512bit (8 QWORDS) source to supplied destination
				;			Prototype:		extern "C" void copy_u( u64* destarr, u64* srcarr )
				;			destarr		-	Address of destination 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			srcarr		-	Address of source 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			returns		-	nothing

 0000003C			copy_u			PROC			PUBLIC
								Copy512			RCX, RDX							; Copy 512 bit space from scr array (address in RDX) to dest (RCX)
 0000003C  48/ 8B 02	     1					MOV				RAX, [ RDX + 0 * 8 ]
 0000003F  48/ 89 01	     1					MOV				[ RCX + 0 * 8 ], RAX
 00000042  48/ 8B 42 08	     1					MOV				RAX, [ RDX + 1 * 8 ]
 00000046  48/ 89 41 08	     1					MOV				[ RCX + 1 * 8 ], RAX
 0000004A  48/ 8B 42 10	     1					MOV				RAX, [ RDX + 2 * 8 ]
 0000004E  48/ 89 41 10	     1					MOV				[ RCX + 2 * 8 ], RAX
 00000052  48/ 8B 42 18	     1					MOV				RAX, [ RDX + 3 * 8 ]
 00000056  48/ 89 41 18	     1					MOV				[ RCX + 3 * 8 ], RAX
 0000005A  48/ 8B 42 20	     1					MOV				RAX, [ RDX + 4 * 8 ]
 0000005E  48/ 89 41 20	     1					MOV				[ RCX + 4 * 8 ], RAX
 00000062  48/ 8B 42 28	     1					MOV				RAX, [ RDX + 5 * 8 ]
 00000066  48/ 89 41 28	     1					MOV				[ RCX + 5 * 8 ], RAX
 0000006A  48/ 8B 42 30	     1					MOV				RAX, [ RDX + 6 * 8 ]
 0000006E  48/ 89 41 30	     1					MOV				[ RCX + 6 * 8 ], RAX
 00000072  48/ 8B 42 38	     1					MOV				RAX, [ RDX + 7 * 8 ]
 00000076  48/ 89 41 38	     1					MOV				[ RCX + 7 * 8 ], RAX
 0000007A  C3							RET	
 0000007B			copy_u			ENDP

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			setuT64		-	set supplied destination 512 bit to supplied u64 value
				;			Prototype:		extern "C" void set_uT64( u64* destarr, u64 value )
				;			destarr		-	Address of destination 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			src			-	u64 value in RDX
				;			returns		-	nothing

 0000007B			set_uT64		PROC			PUBLIC
								Zero512			RCX	
 0000007B  48/ 33 C0	     1					XOR				RAX, RAX
 0000007E  48/ 89 01	     1					MOV				[ RCX + 0 * 8 ], RAX
 00000081  48/ 89 41 08	     1					MOV				[ RCX + 1 * 8 ], RAX
 00000085  48/ 89 41 10	     1					MOV				[ RCX + 2 * 8 ], RAX
 00000089  48/ 89 41 18	     1					MOV				[ RCX + 3 * 8 ], RAX
 0000008D  48/ 89 41 20	     1					MOV				[ RCX + 4 * 8 ], RAX
 00000091  48/ 89 41 28	     1					MOV				[ RCX + 5 * 8 ], RAX
 00000095  48/ 89 41 30	     1					MOV				[ RCX + 6 * 8 ], RAX
 00000099  48/ 89 41 38	     1					MOV				[ RCX + 7 * 8 ], RAX
 0000009D  48/ 89 51 38						MOV				Q_PTR [ RCX + 7 * 8 ], RDX
 000000A1  C3							RET	
 000000A2			set_uT64		ENDP

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			compare_u	-	unsigned compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
				;			Prototype:		extern "C" s32 compare_u( u64* lh_op, u64* rh_op )
				;			lh_op		-	Address of LH 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			rh_op		-	Address of RH 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			returns		-	(0) for equal, -1 for less than, 1 for greater than
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore

 000000A2			compare_u		PROC			PUBLIC

								CheckAlign		RCX
								CheckAlign		RDX

					IF __UseZ
					ELSE

				; FOR EACH index of 0 thru 7 : fetch qword of lh_op, compare to qword of rh_op; jump to exit if not equal
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
								MOV				RAX, [ RCX + idx * 8 ]
								CMP				RAX, [ RDX + idx * 8 ]
								JNZ				@F
								ENDM
 000000A2  48/ 8B 01	     1					MOV				RAX, [ RCX + 0 * 8 ]
 000000A5  48/ 3B 02	     1					CMP				RAX, [ RDX + 0 * 8 ]
 000000A8  75 46	     1					JNZ				@F
 000000AA  48/ 8B 41 08	     1					MOV				RAX, [ RCX + 1 * 8 ]
 000000AE  48/ 3B 42 08	     1					CMP				RAX, [ RDX + 1 * 8 ]
 000000B2  75 3C	     1					JNZ				@F
 000000B4  48/ 8B 41 10	     1					MOV				RAX, [ RCX + 2 * 8 ]
 000000B8  48/ 3B 42 10	     1					CMP				RAX, [ RDX + 2 * 8 ]
 000000BC  75 32	     1					JNZ				@F
 000000BE  48/ 8B 41 18	     1					MOV				RAX, [ RCX + 3 * 8 ]
 000000C2  48/ 3B 42 18	     1					CMP				RAX, [ RDX + 3 * 8 ]
 000000C6  75 28	     1					JNZ				@F
 000000C8  48/ 8B 41 20	     1					MOV				RAX, [ RCX + 4 * 8 ]
 000000CC  48/ 3B 42 20	     1					CMP				RAX, [ RDX + 4 * 8 ]
 000000D0  75 1E	     1					JNZ				@F
 000000D2  48/ 8B 41 28	     1					MOV				RAX, [ RCX + 5 * 8 ]
 000000D6  48/ 3B 42 28	     1					CMP				RAX, [ RDX + 5 * 8 ]
 000000DA  75 14	     1					JNZ				@F
 000000DC  48/ 8B 41 30	     1					MOV				RAX, [ RCX + 6 * 8 ]
 000000E0  48/ 3B 42 30	     1					CMP				RAX, [ RDX + 6 * 8 ]
 000000E4  75 0A	     1					JNZ				@F
 000000E6  48/ 8B 41 38	     1					MOV				RAX, [ RCX + 7 * 8 ]
 000000EA  48/ 3B 42 38	     1					CMP				RAX, [ RDX + 7 * 8 ]
 000000EE  75 00	     1					JNZ				@F

 000000F0			@@:
 000000F0  48/ C7 C0						MOV				RAX, 0
	   00000000
 000000F7  0F 4F 05						CMOVG			EAX, ret1
	   00000004 R
 000000FE  0F 4C 05						CMOVL			EAX, ret_1
	   00000008 R
 00000105  C3							RET
					ENDIF
 00000106			compare_u		ENDP 

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			compare_uT64-	unsigned compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand
				;			Prototype:		extern "C" s32 compare_uT64( u64* lh_op, u64 rh_op )
				;			lh_op		-	Address of LH 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			rh_op		-	The RH 64-bit value in RDX
				;			returns		-	(0) for equal, -1 for less than, 1 for greater than
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore

 00000106			compare_uT64	PROC			PUBLIC
								
								CheckAlign		RCX

					IF		__UseZ
					ELSE
 00000106  48/ 33 C0						XOR				RAX, RAX
				; FOR EACH index 0 thru 6: Get minuend QWORD, compare for zero 
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6 >
								CMP				Q_PTR [ RCX + idx * 8 ], RAX
								JNZ				@F
								ENDM
 00000109  48/ 39 01	     1					CMP				Q_PTR [ RCX + 0 * 8 ], RAX
 0000010C  75 2F	     1					JNZ				@F
 0000010E  48/ 39 41 08	     1					CMP				Q_PTR [ RCX + 1 * 8 ], RAX
 00000112  75 29	     1					JNZ				@F
 00000114  48/ 39 41 10	     1					CMP				Q_PTR [ RCX + 2 * 8 ], RAX
 00000118  75 23	     1					JNZ				@F
 0000011A  48/ 39 41 18	     1					CMP				Q_PTR [ RCX + 3 * 8 ], RAX
 0000011E  75 1D	     1					JNZ				@F
 00000120  48/ 39 41 20	     1					CMP				Q_PTR [ RCX + 4 * 8 ], RAX
 00000124  75 17	     1					JNZ				@F
 00000126  48/ 39 41 28	     1					CMP				Q_PTR [ RCX + 5 * 8 ], RAX
 0000012A  75 11	     1					JNZ				@F
 0000012C  48/ 39 41 30	     1					CMP				Q_PTR [ RCX + 6 * 8 ], RAX
 00000130  75 0B	     1					JNZ				@F

 00000132  48/ 8B 41 38						MOV				RAX, [ RCX + 7 * 8 ]
 00000136  48/ 3B C2						CMP				RAX, RDX 
 00000139  75 02						JNZ				@F
 0000013B  33 C0						XOR				EAX, EAX
 0000013D  0F 4F 05		@@:				CMOVG			EAX, ret1
	   00000004 R
 00000144  0F 4C 05						CMOVL			EAX, ret_1
	   00000008 R
 0000014B  C3							RET
					ENDIF
 0000014C			compare_uT64 ENDP

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			add_u		-	unsigned add supplied 512bit (8 QWORDS) sources to supplied destination
				;			Prototype:		extern "C" s32 add_u( u64* sum, u64* addend1, u64* addend2 )
				;			sum			-	Address of 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			addend1		-	Address of  the 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			addend2		-	Address of  the 64 byte aligned array of 8 64-bit QWORDS (512 bits) in R8
				;			returns		-	zero for no carry, 1 for carry (overflow)
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore

 0000014C			add_u			PROC			PUBLIC 

								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8	

					IF	__UseZ
					ELSE

 0000014C  48/ 8B 42 38						MOV				RAX, [ RDX + 7 * 8 ]
 00000150  49/ 03 40 38						ADD				RAX, [ R8 + 7 * 8 ]
 00000154  48/ 89 41 38						MOV				[ RCX + 7 * 8 ], RAX

				; FOR EACH index of 6 thru 0 : fetch qword of addend1 (RDX), add (with carry) to qword of addend2; store at callers sum			
								FOR				idx, < 6, 5, 4, 3, 2, 1, 0 >
								MOV				RAX, [ RDX + idx * 8 ]
								ADCX			RAX, [ R8 + idx * 8 ]
								MOV				[ RCX + idx * 8 ] , RAX
								ENDM
 00000158  48/ 8B 42 30	     1					MOV				RAX, [ RDX + 6 * 8 ]
 0000015C  66| 49/ 0F 38 F6  1					ADCX			RAX, [ R8 + 6 * 8 ]
	   40 30
 00000163  48/ 89 41 30	     1					MOV				[ RCX + 6 * 8 ] , RAX
 00000167  48/ 8B 42 28	     1					MOV				RAX, [ RDX + 5 * 8 ]
 0000016B  66| 49/ 0F 38 F6  1					ADCX			RAX, [ R8 + 5 * 8 ]
	   40 28
 00000172  48/ 89 41 28	     1					MOV				[ RCX + 5 * 8 ] , RAX
 00000176  48/ 8B 42 20	     1					MOV				RAX, [ RDX + 4 * 8 ]
 0000017A  66| 49/ 0F 38 F6  1					ADCX			RAX, [ R8 + 4 * 8 ]
	   40 20
 00000181  48/ 89 41 20	     1					MOV				[ RCX + 4 * 8 ] , RAX
 00000185  48/ 8B 42 18	     1					MOV				RAX, [ RDX + 3 * 8 ]
 00000189  66| 49/ 0F 38 F6  1					ADCX			RAX, [ R8 + 3 * 8 ]
	   40 18
 00000190  48/ 89 41 18	     1					MOV				[ RCX + 3 * 8 ] , RAX
 00000194  48/ 8B 42 10	     1					MOV				RAX, [ RDX + 2 * 8 ]
 00000198  66| 49/ 0F 38 F6  1					ADCX			RAX, [ R8 + 2 * 8 ]
	   40 10
 0000019F  48/ 89 41 10	     1					MOV				[ RCX + 2 * 8 ] , RAX
 000001A3  48/ 8B 42 08	     1					MOV				RAX, [ RDX + 1 * 8 ]
 000001A7  66| 49/ 0F 38 F6  1					ADCX			RAX, [ R8 + 1 * 8 ]
	   40 08
 000001AE  48/ 89 41 08	     1					MOV				[ RCX + 1 * 8 ] , RAX
 000001B2  48/ 8B 02	     1					MOV				RAX, [ RDX + 0 * 8 ]
 000001B5  66| 49/ 0F 38 F6  1					ADCX			RAX, [ R8 + 0 * 8 ]
	   00
 000001BB  48/ 89 01	     1					MOV				[ RCX + 0 * 8 ] , RAX

 000001BE  48/ C7 C0						MOV				RAX, 0							; return carry flag as overflow
	   00000000
 000001C5  0F 42 05						CMOVC			EAX, ret1
	   00000004 R
 000001CC  C3							RET	

					ENDIF
 000001CD			add_u			ENDP

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			add_uT64	-	add supplied 64bit QWORD (value) to 512bit (8 QWORDS), place in supplied destination
				;			Prototype:		extern "C" s32 add_uT64( u64* sum, u64* addend1, u64 addend2 )
				;			sum			-	Address of 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			addend1		-	Address of  the 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			addend2		-	The 64-bit value in R8
				;			returns		-	zero for no carry, 1 for carry (overflow)
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore

 000001CD			add_uT64		PROC			PUBLIC 

								CheckAlign		RCX
								CheckAlign		RDX

					IF __UseZ
					ELSE

				; First Addition, Get Least significant QWORD of addend, Add passed QWORD to it
 000001CD  48/ 8B 42 38						MOV				RAX, [ RDX + 7 * 8 ]
 000001D1  49/ 03 C0						ADD				RAX, R8 
 000001D4  48/ 89 41 38						MOV				[ RCX + 7 * 8 ], RAX
				; FOR EACH index 6 thru 0: Get addend QWORD, add zero, but with carry if any from previous add
								FOR				idx, < 6, 5, 4, 3, 2, 1, 0 >
								MOV				RAX, [ RDX + idx * 8 ]
								ADC				RAX, 0
								MOV				[ RCX + idx * 8 ], RAX
								ENDM
 000001D8  48/ 8B 42 30	     1					MOV				RAX, [ RDX + 6 * 8 ]
 000001DC  48/ 83 D0 00	     1					ADC				RAX, 0
 000001E0  48/ 89 41 30	     1					MOV				[ RCX + 6 * 8 ], RAX
 000001E4  48/ 8B 42 28	     1					MOV				RAX, [ RDX + 5 * 8 ]
 000001E8  48/ 83 D0 00	     1					ADC				RAX, 0
 000001EC  48/ 89 41 28	     1					MOV				[ RCX + 5 * 8 ], RAX
 000001F0  48/ 8B 42 20	     1					MOV				RAX, [ RDX + 4 * 8 ]
 000001F4  48/ 83 D0 00	     1					ADC				RAX, 0
 000001F8  48/ 89 41 20	     1					MOV				[ RCX + 4 * 8 ], RAX
 000001FC  48/ 8B 42 18	     1					MOV				RAX, [ RDX + 3 * 8 ]
 00000200  48/ 83 D0 00	     1					ADC				RAX, 0
 00000204  48/ 89 41 18	     1					MOV				[ RCX + 3 * 8 ], RAX
 00000208  48/ 8B 42 10	     1					MOV				RAX, [ RDX + 2 * 8 ]
 0000020C  48/ 83 D0 00	     1					ADC				RAX, 0
 00000210  48/ 89 41 10	     1					MOV				[ RCX + 2 * 8 ], RAX
 00000214  48/ 8B 42 08	     1					MOV				RAX, [ RDX + 1 * 8 ]
 00000218  48/ 83 D0 00	     1					ADC				RAX, 0
 0000021C  48/ 89 41 08	     1					MOV				[ RCX + 1 * 8 ], RAX
 00000220  48/ 8B 02	     1					MOV				RAX, [ RDX + 0 * 8 ]
 00000223  48/ 83 D0 00	     1					ADC				RAX, 0
 00000227  48/ 89 01	     1					MOV				[ RCX + 0 * 8 ], RAX

				; return zero unless carry still exists from addition
 0000022A  8B 05 00000000 R					MOV				EAX, ret0
 00000230  0F 42 05						CMOVC			EAX, ret1
	   00000004 R
 00000237  C3							RET	
					ENDIF

 00000238			add_uT64		ENDP 
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			sub_u		-	subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
				;			Prototype:		extern "C" s32 sub_u( u64* difference, u64* left operand, u64* right operand )
				;			difference	-	Address of 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of the LHOP 8 64-bit QWORDS (512 bits) in RDX
				;			rh_op		-	Address of the RHOP 8 64-bit QWORDS (512 bits) in R8
				;			returns		-	zero for no borrow, 1 for borrow (underflow)
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore

 00000238			sub_u			PROC			PUBLIC 

								CheckAlign		RCX
								CheckAlign		RDX
								CheckAlign		R8

					IF __UseZ
					ELSE

 00000238  48/ 8B 42 38						MOV				RAX, [ RDX + 7 * 8 ]				; get last word of minuend (least significant word of the number we are subtracting from) (left-hand operand)
 0000023C  49/ 2B 40 38						SUB				RAX, [ R8 + 7 * 8 ]					; subtract last word of subrahend (the number to be subtracted) (right-hand operand)
 00000240  48/ 89 41 38						MOV				[ RCX + 7 * 8 ], RAX				; store result in last word of difference, note: the flag 'carry' has been set to whether there has been a 'borrow'

				; FOR EACH index 6 thru 0: Get minuend QWORD, subtract (with borrow), store at difference
								FOR				idx, < 6, 5, 4, 3, 2, 1, 0 >
								MOV				RAX, [ RDX + idx * 8]					
								SBB				RAX, [ R8 + idx * 8 ]
								MOV				[ RCX + idx * 8 ], RAX
								ENDM
 00000244  48/ 8B 42 30	     1					MOV				RAX, [ RDX + 6 * 8]					
 00000248  49/ 1B 40 30	     1					SBB				RAX, [ R8 + 6 * 8 ]
 0000024C  48/ 89 41 30	     1					MOV				[ RCX + 6 * 8 ], RAX
 00000250  48/ 8B 42 28	     1					MOV				RAX, [ RDX + 5 * 8]					
 00000254  49/ 1B 40 28	     1					SBB				RAX, [ R8 + 5 * 8 ]
 00000258  48/ 89 41 28	     1					MOV				[ RCX + 5 * 8 ], RAX
 0000025C  48/ 8B 42 20	     1					MOV				RAX, [ RDX + 4 * 8]					
 00000260  49/ 1B 40 20	     1					SBB				RAX, [ R8 + 4 * 8 ]
 00000264  48/ 89 41 20	     1					MOV				[ RCX + 4 * 8 ], RAX
 00000268  48/ 8B 42 18	     1					MOV				RAX, [ RDX + 3 * 8]					
 0000026C  49/ 1B 40 18	     1					SBB				RAX, [ R8 + 3 * 8 ]
 00000270  48/ 89 41 18	     1					MOV				[ RCX + 3 * 8 ], RAX
 00000274  48/ 8B 42 10	     1					MOV				RAX, [ RDX + 2 * 8]					
 00000278  49/ 1B 40 10	     1					SBB				RAX, [ R8 + 2 * 8 ]
 0000027C  48/ 89 41 10	     1					MOV				[ RCX + 2 * 8 ], RAX
 00000280  48/ 8B 42 08	     1					MOV				RAX, [ RDX + 1 * 8]					
 00000284  49/ 1B 40 08	     1					SBB				RAX, [ R8 + 1 * 8 ]
 00000288  48/ 89 41 08	     1					MOV				[ RCX + 1 * 8 ], RAX
 0000028C  48/ 8B 02	     1					MOV				RAX, [ RDX + 0 * 8]					
 0000028F  49/ 1B 00	     1					SBB				RAX, [ R8 + 0 * 8 ]
 00000292  48/ 89 01	     1					MOV				[ RCX + 0 * 8 ], RAX

 00000295  48/ C7 C0						MOV				RAX, 0								; return, set return code to zero if no remaining borrow, to one if there is a borrow
	   00000000
 0000029C  0F 42 05						CMOVC			EAX, ret1
	   00000004 R
 000002A3  C3							RET
					ENDIF
 000002A4			sub_u			ENDP 

				;
;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			sub_uT64	-	subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
				;			Prototype:		extern "C" s32 sub_uT64( u64* difference, u64* left operand, u64 right operand )
				;			difference	-	Address of 64 byte alligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			lh_op		-	Address of  the 64 byte aligned array of 8 64-bit QWORDS (512 bits) in RDX
				;			rh_op		-	64-bitvalue in R8
				;			returns		-	zero for no borrow, 1 for borrow (underflow)
				;			Note: unrolled code instead of loop: faster, and no regs to save / setup / restore

 000002A4			sub_uT64		PROC			PUBLIC 

								CheckAlign		RCX
								CheckAlign		RDX

					IF __UseZ
					ELSE
 000002A4  48/ 8B 42 38						MOV				RAX, [ RDX + 7 * 8 ]		; 
 000002A8  49/ 2B C0						SUB				RAX, R8
 000002AB  48/ 89 41 38						MOV				[ RCX + 7 * 8 ], RAX

				; FOR EACH index 6 thru 0: Get minuend QWORD, subtract borrow (if any), store at difference
								FOR				idx, < 6, 5, 4, 3, 2, 1, 0 >
								MOV				RAX, [ RDX + idx * 8]					
								SBB				RAX, 0
								MOV				[ RCX + idx * 8 ], RAX
								ENDM
 000002AF  48/ 8B 42 30	     1					MOV				RAX, [ RDX + 6 * 8]					
 000002B3  48/ 83 D8 00	     1					SBB				RAX, 0
 000002B7  48/ 89 41 30	     1					MOV				[ RCX + 6 * 8 ], RAX
 000002BB  48/ 8B 42 28	     1					MOV				RAX, [ RDX + 5 * 8]					
 000002BF  48/ 83 D8 00	     1					SBB				RAX, 0
 000002C3  48/ 89 41 28	     1					MOV				[ RCX + 5 * 8 ], RAX
 000002C7  48/ 8B 42 20	     1					MOV				RAX, [ RDX + 4 * 8]					
 000002CB  48/ 83 D8 00	     1					SBB				RAX, 0
 000002CF  48/ 89 41 20	     1					MOV				[ RCX + 4 * 8 ], RAX
 000002D3  48/ 8B 42 18	     1					MOV				RAX, [ RDX + 3 * 8]					
 000002D7  48/ 83 D8 00	     1					SBB				RAX, 0
 000002DB  48/ 89 41 18	     1					MOV				[ RCX + 3 * 8 ], RAX
 000002DF  48/ 8B 42 10	     1					MOV				RAX, [ RDX + 2 * 8]					
 000002E3  48/ 83 D8 00	     1					SBB				RAX, 0
 000002E7  48/ 89 41 10	     1					MOV				[ RCX + 2 * 8 ], RAX
 000002EB  48/ 8B 42 08	     1					MOV				RAX, [ RDX + 1 * 8]					
 000002EF  48/ 83 D8 00	     1					SBB				RAX, 0
 000002F3  48/ 89 41 08	     1					MOV				[ RCX + 1 * 8 ], RAX
 000002F7  48/ 8B 02	     1					MOV				RAX, [ RDX + 0 * 8]					
 000002FA  48/ 83 D8 00	     1					SBB				RAX, 0
 000002FE  48/ 89 01	     1					MOV				[ RCX + 0 * 8 ], RAX

 00000301  48/ C7 C0						MOV				RAX, 0
	   00000000
 00000308  0F 42 05						CMOVC			EAX, ret1
	   00000004 R
 0000030F  C3							RET
					ENDIF

 00000310			sub_uT64		ENDP 

								END
Microsoft (R) Macro Assembler (x64) Version 14.43.34808.0   03/03/25 23:14:25
ui512a.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckAlign . . . . . . . . . . .	Proc
Copy512  . . . . . . . . . . . .	Proc
GetZatMask . . . . . . . . . . .	Proc
MemConstants . . . . . . . . . .	Proc
SetZatMask . . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

add_uT64 . . . . . . . . . . . .	P 	 000001CD _TEXT	Length= 0000006B Public
add_u  . . . . . . . . . . . . .	P 	 0000014C _TEXT	Length= 00000081 Public
compare_uT64 . . . . . . . . . .	P 	 00000106 _TEXT	Length= 00000046 Public
compare_u  . . . . . . . . . . .	P 	 000000A2 _TEXT	Length= 00000064 Public
copy_u . . . . . . . . . . . . .	P 	 0000003C _TEXT	Length= 0000003F Public
set_uT64 . . . . . . . . . . . .	P 	 0000007B _TEXT	Length= 00000027 Public
sub_uT64 . . . . . . . . . . . .	P 	 000002A4 _TEXT	Length= 0000006C Public
sub_u  . . . . . . . . . . . . .	P 	 00000238 _TEXT	Length= 0000006C Public
zero_u . . . . . . . . . . . . .	P 	 00000019 _TEXT	Length= 00000023 Public


Symbols:

                N a m e                 Type     Value    Attr

B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPFALSE  . . . . . . . . . . . .	Number	 00000003h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
CPTRUE . . . . . . . . . . . . .	Number	 00000007h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Mask20 . . . . . . . . . . . . .	Text   	 
MaskBit0 . . . . . . . . . . . .	Number	 00000001h   
MaskBit1 . . . . . . . . . . . .	Number	 00000002h   
MaskBit2 . . . . . . . . . . . .	Number	 00000004h   
MaskBit3 . . . . . . . . . . . .	Number	 00000008h   
MaskBit4 . . . . . . . . . . . .	Number	 00000010h   
MaskBit5 . . . . . . . . . . . .	Number	 00000020h   
MaskBit6 . . . . . . . . . . . .	Number	 00000040h   
MaskBit7 . . . . . . . . . . . .	Number	 00000080h   
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__CheckAlign . . . . . . . . . .	Number	 00000000h   
__UseQ . . . . . . . . . . . . .	Number	 00000001h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000000h   
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
mskAll8  . . . . . . . . . . . .	Byte	 0000000C _TEXT	
mskB0  . . . . . . . . . . . . .	Byte	 0000000D _TEXT	
mskB1  . . . . . . . . . . . . .	Byte	 0000000E _TEXT	
mskB2  . . . . . . . . . . . . .	Byte	 0000000F _TEXT	
mskB3  . . . . . . . . . . . . .	Byte	 00000010 _TEXT	
mskB4  . . . . . . . . . . . . .	Byte	 00000011 _TEXT	
mskB5  . . . . . . . . . . . . .	Byte	 00000012 _TEXT	
mskB6  . . . . . . . . . . . . .	Byte	 00000013 _TEXT	
mskB7  . . . . . . . . . . . . .	Byte	 00000014 _TEXT	
mskHex100  . . . . . . . . . . .	DWord	 00000015 _TEXT	
ret0 . . . . . . . . . . . . . .	DWord	 00000000 _TEXT	
ret1 . . . . . . . . . . . . . .	DWord	 00000004 _TEXT	
ret_1  . . . . . . . . . . . . .	DWord	 00000008 _TEXT	
ui512aMacros_INC . . . . . . . .	Text   	 1

	   0 Warnings
	   0 Errors
